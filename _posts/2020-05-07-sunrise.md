---
layout: post
title: A Sunrise Alarm Clock
require_latex: true
hidden: true
---

I built a sunrise alarm clock so I wouldn't need to wake up in the dark during the winter time when the sun rises very late. This was the first PCB I had ever made and I had a lot of fun with it. The hardware and firmware is all [on github](https://github.com/tyehle/sunrise).

{% include figure.html
    contents='![sunrise-board](/resources/sunrise/sunrise-board.jpeg)'
    caption='The completed project'
%}

The board is powered by an Atmega 328 and has, in no particular order:
- Three power transistors to control the RGB channels of an LED strip
- A power regulator so it can be powered by a 12V wall wart
- A real time clock with a battery backup to keep track of the time
- No surface mount parts because I wasn't sure I could solder them
- Dope sunrise art

## Contents
{: .no_toc}

* Placeholder toc list
{:toc}

---

# Hardware Development

## In the Beginning

I started this project with a cheap clone of the Arduino pro mini driving an LED strip, and the first time I left it on overnight it burned out the power regulator. This probably would not have happened to a legit Arduino pro mini, but the cheap clones have to make compromises in the design to lower costs, and the power regulator is a good way to save on component costs.

I was also keeping track of the time using the Atmega's clock, but this isn't the best approach because if the board lost power for any reason then it would lose the time. Maybe for a microwave that is ok, but not for an alarm clock (Why don't microwaves save the time? An RTC only costs a few dollars).

{% include figure.html
    contents='![ldo-example](/resources/sunrise/ldo-example.png)'
    caption='Test circuit from [the datasheet](https://www.st.com/resource/en/datasheet/l4931.pdf#page=6) of the L4931 voltage regulator'
%}

My second attempt used [a real time clock (RTC) module](https://www.adafruit.com/product/3296) I bought from Adafruit, and [a better power regulator](https://www.mouser.com/ProductDetail/511-L4931CZ50-AP). Figuring out how to use this power regulator was straightforward because [its datasheet](https://www.st.com/resource/en/datasheet/l4931.pdf#page=6) has an example circuit that was exactly what I was trying to do. All this assembled on a breadboard worked great! The LEDs powered up at the scheduled time, but the barrel jack was really easy to accidentally pull out of the bread board, so I decided I needed to solder some components into a circuit board.


## The Circuit Board Design

[The schematic](https://www.arduino.cc/en/uploads/Main/Arduino-Pro-Mini-schematic.pdf) for the Arduino is open source, so most of the work I needed to do was already done. I knew I wanted to use the L4931 regulator and a barrel connector to provide power to the board, so I subbed those into the power regulation section of the Arduino's schematic. The stabilization caps on the Arduino design are larger than those suggested by the L4931 datasheet, so I used the larger ones just to be safe. I have since learned that the smaller ceramic capacitor is used to smooth out higher frequency variations in the output voltage. It has a much lower equivalent series resistance (ESR) than an electrolytic capacitor so it can respond faster, but large ceramic caps are expensive, so the electrolytic capacitor smooths out any low frequency noise on the cheap and the ceramic cap takes care of the high frequency noise. There is also an optional power indication LED I chose not to solder into the board I use because I don't like lights on things in my bedroom.

{% include figure.html
    contents='![power-regulation](/resources/sunrise/power-regulation.svg){:width="100%"}'
    caption='Power regulation with an electrolytic and ceramic cap to filter output voltage'
%}

The design of the RTC breakout from Adafruit is not open source, but [the datasheet for the DS1307](https://datasheets.maximintegrated.com/en/ds/DS1307.pdf) is excellent and has an example on the very first page! I sure do appreciate good documentation. There is one additional component on the breakout board I got from Adafruit, but I think it is just a power stabilization capacitor. This clock will keep the time using the backup battery if main power is lost, so if I unplug the board, or the power goes out I don't need to reset the clock. The two pull-up resistors on the `SDA` and `SCL` lines are required by the I<sup>2</sup>C spec. The 32.768kHz crystal is a requirement of the chip. This is a very popular speed for clocks because it makes counting seconds so easy because 32,768 is 2<sup>15</sup>.

{% include figure.html
    contents='![rtc](/resources/sunrise/rtc.svg){:width="80%"}'
    caption='DS1307 Real Time Clock'
%}

I replicated the setup I had on the original breadboard design for the high power output transistors. The gates are connected to PWM capable outputs on the microcontroller and provide a high capacity current sink for the LED strip when on. Most of the strands I've seen are powered off of 12V and use a common high voltage line, so this setup should be compatible with many LED strips. The pull down resistors on the outputs here prevent the LED strip from momentarily turning on when the microcontroller is reset. The Atmega 328 [sets all pins to input without pull up resistors when it is reset](https://forum.arduino.cc/index.php?topic=57829.msg421711#msg421711) so the voltage at the mosfet gate would be left floating, potentially allowing it to turn on.

{% include figure.html
    contents='![output-transistors](/resources/sunrise/output-transistors.svg){:width="60%"}'
    caption='High current output transistors for the RGB channels of the LED strip'
%}

The rest of the schematic is the same as the Arduino board I was using. There is another power stabilization cap drawn very close to the microcontroller. In this case this means that the cap should be physically close to the microcontroller on the board to provide a very stable voltage for it to use. The microcontroller will probably use different amounts of current at high frequency, so this makes sense to me.

The other interesting bit of this part of the schematic is the reset hardware. There is a cap between the `DTR` pin on the programming header and the reset pin on the microcontroller with a pull-up resistor. This is so that if software fails to pull the `DTR` pin high again the board will still reboot after charging the capacitor through the pull-up resistor. The values of the capacitor and resistor here have been tuned so the board is only momentarily off and can talk to the computer properly even if there are bad drivers for the programming cable.

{% include figure.html
    contents='![micro-controller](/resources/sunrise/micro-controller.svg){:width="100%"}'
    caption='GPIO and reset for the Atmega328'
%}


## Circuit Board Layout

I decided to use only through hole parts because I wasn't sure I had the skill to solder surface mount components. I also wanted to make sure I could debug and expand the design, so I wanted all the standard Arduino pins to be accessible if I plugged it into a bread board. All this means that the board is very skinny so it would fit on a bread board and in order for there to be any room left on the bread board it has to hang way off the end.

{% include figure.html
    contents='![top](/resources/sunrise/top.svg){:width="100%"}'
    caption='Top of the board with many tiny suns'
%}

{% include figure.html
    contents='![bottom](/resources/sunrise/bottom.svg){:width="100%"}'
    caption='Bottom of the board with one huge rising sun'
%}


---

# The Firmware

## Color Profile
When I first started thinking about a sunrise alarm clock I thought it would be neat to have it run through the colors of the *actual* sky during a sunrise. Surely somebody has collected such data. As I tried to find a dataset I discovered that "the sky at sunrise" isn't a very precise idea. What angle above the horizon? East, West, straight up, or some other azimuth? A single point or the average color over an area? Are there clouds? If so where? Is there haze in the air?

I decided this was too much and I should instead choose a color profile that seemed natural without any relation to The Real Sky. I settled on the color of a perfect black body radiator because it goes from red to "white" which seemed nice, and there is a nice physical metaphor with the light source warming up for the day. I got some data about [hue for different temperatures here](http://www.vendian.org/mncharity/dir3/blackbody/). The colors in this dataset were converted using a D65 whitepoint, which is why I think there is a kink in the plot around 6500K. I played around with this data a bit and decided I liked the look of a ramp from 1000K up to 4500K. This leaves the lights a little more yellow than a true white which I find nice in the morning.

{% include figure.html
    contents='![brightness](/resources/sunrise/blackbody-rgb.svg){:width="100%"}'
    caption='Color channel values for different temperature blackbody radiators using a D65 whitepoint'
%}

The intensity of a true blackbody goes up way too fast to be a satisfying light, and since our eyes respond exponentially, I thought an exponential brightness curve would look nice. The lights need to start off and end at fully bright over some period of time, so the brightness function $$B(t)$$ will need satisfy $$B(0)=0$$ and $$B(1)=1$$. By shifting the exponential function down by one and then using horizontal and vertical stretching I can ensure that our needs are met while still leaving a parameter free for the steepness of the curve. The exponential function with a vertical shift of -1, a vertical stretch of $$k$$, and a horizontal stretch of $$a$$ is $$ B_k(t) = k \left( e^{a t} - 1 \right) $$. Solving $$B_k(1) = 1$$ to gives $$a = \ln\left(\frac{1}{k} + 1\right)$$, leaving $$k$$ as the single steepness parameter. The full brightness function is then

$$ B_k(t) = k \left( \exp \left( t \ln \left( \frac{1}{k} + 1 \right) \right) - 1 \right) $$

{% include figure.html
    contents='![brightness](/resources/sunrise/exponential-brightness.svg){:width="100%"}'
    caption='The brightness function $$B_k(t)$$ for some values of $$k$$. For the lights I have, $$k=\frac{1}{8}$$ looks the best.'
%}


## Normalization

The blue LEDs on the strip I have seemed much brighter than the green or red channels, so I knew I needed to tone them down, but by how much? To determine this I took a picture of a white sheet of paper lit by the LEDs at full power and then looked at a histogram of each color channel.

{% include figure.html
    contents='![white histogram](/resources/sunrise/white-hist.svg){:width="100%"}'
    caption='LEDs at full power reflecting off a white sheet of paper'
%}

Normalizing the green and blue channels to the max output of the red LEDs means that "full power" for the green channel should be $$\frac{87}{96} \cdot 255 = 231$$, and for the blue channel $$\frac{87}{179} \cdot 255 = 124$$.


## High precision PWM

The difference between the lights being off, and being on at 1/255 power is pretty jarring. At higher powers the steps become less noticeable, but the first few steps are very clearly visible. This is why people usually recommend a

When the lights first turn on, only the red channel comes on, and

16 bit PWM signal in hardware is possible on pins 9 and 10

---

# Wishlist

- A better UI (a button to reset and turn off)
- Mounting holes on the board
- A case
- Better interfacing with the LED strip (terminal blocks? is header good enough?)